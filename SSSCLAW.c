#pragma config(UART_Usage, UART1, uartVEXLCD, baudRate19200, IOPins, None, None)
#pragma config(UART_Usage, UART2, uartNotUsed, baudRate4800, IOPins, None, None)
#pragma config(Sensor, in1,    importantVoltagePort, sensorAnalog)
#pragma config(Sensor, in2,    PL,             sensorPotentiometer)
#pragma config(Sensor, in3,    Gyro,           sensorGyro)
#pragma config(Sensor, in4,    PIN,            sensorPotentiometer)
#pragma config(Sensor, dgtl1,  QL,             sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  QR,             sensorQuadEncoder)
#pragma config(Motor,  port2,           D1,            tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           D2,            tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port4,           LL,            tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           RL,            tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           CK,            tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           SK,            tmotorVex393_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//**ABBREVIATION MEANINGS IN CASE ANYONE READS THIS THAT ISN'T ME/FOR THE NOTEBOOK AS WELL**//
//PL = Lift Potentiometer.
//PIN = Intake Potentiometer.
//QR/QL = Quad encoder left/Quad encoder right.
//D1 = Left drive train motors.
//D2 = Right drive train motors.
//LL = Left lift motors.
//RL = Right lift motors.
//CK = (Cone Keeper); Intake motor for the cones.
//SK = (Score Keeper); MoGo holder motor.
//**LOOK OUT FOR COMMENTS FOR SENSOR/MOTOR ADJUSTMENTS**//
///////////////////////**FOR PID ONCE WE GET THERE**///////////////////////
//dgtl1 IS FOR THE LEFT SIDE.
//dgtl3 IS FOR THE RIGHT SIDE.
////**IF WE GO WITH IME'S MAKE SURE TO REPLACE THESE**////
const short leftButton = 1;
const short centerButton = 2;
const short rightButton = 4;
int count = 0;
int driver = 0;
int maxthresholdCK = 85;
int thresholdlift = 40;
int thresholddrive = 30;
int thresholdCK = 20;
//////////////////////////////////////////////////////////////////////////////////////
#pragma platform(VEX2)
#pragma competitionControl(Competition)
#include "Vex_Competition_Includes.c"
//////////////////////////////////////////////////////////////////////////////////////
task LCD()
{
	while(true)
	{
		clearLCDLine(0);
		clearLCDLine(1);
		bLCDBacklight = true;
		string mainBattery, expander;
		displayLCDString(0, 0, "Primary: ");
		sprintf(mainBattery, "%1.2f%c", nImmediateBatteryLevel/1000.0,'V');
		displayNextLCDString(mainBattery);
		displayLCDString(1, 0, "Expander: ");
		sprintf(expander, "%1.2f%c", (SensorValue[importantVoltagePort])/300.0, 'V');
		displayNextLCDString(expander);
		wait1Msec(100);
	}
}
//////////////////////////////////////////////////////////////////////////////////////
task singleController1()//SINGLE ARCADE STYLE
{
	while(true)
	{
		if((abs(vexRT[Ch3]) > thresholddrive) || (abs(vexRT[Ch4]) > thresholddrive))
		{
			motor[D1] = (vexRT[Ch3] + vexRT[Ch4]);
			motor[D2] = (vexRT[Ch3] - vexRT[Ch4]);
		}
		else
		{
			motor[D1]=0;
			motor[D2]=0;
		}
		if(abs(vexRT[Ch2]) > thresholdlift)
		{
			motor[LL]=vexRT[Ch2];
			motor[RL]=vexRT[Ch2];
		}
		else
		{
			motor[LL]=0;
			motor[RL]=0;
		}
		if((vexRT[Btn5D]==1) && (vexRT[Btn5U]==0))
		{
			motor[SK]=-127;
		}
		if((vexRT[Btn5U]==1) && (vexRT[Btn5D]==0))
		{
			motor[SK]=127;
		}
		else if((vexRT[Btn5U]==0) && (vexRT[Btn5D]==0))
		{
			motor[SK]=0;
		}
		if((vexRT[Btn6D]==1) && (vexRT[Btn6U]==0))
		{
			motor[CK]=-63
			;
		}
		if((vexRT[Btn6U]==1) && (vexRT[Btn6D]==0))
		{
			motor[CK]=63;
		}
		else if((vexRT[Btn6U]==0) && (vexRT[Btn6D]==0))
		{
			motor[CK]=0;
		}
	}
}
//////////////////////////////////////////////////////////////////////////////////////
task singleController2()//SINGLE TANK STYLE
{
	while(true)
	{
		if(abs(vexRT[Ch3]) > thresholddrive)
		{
			motor[D1]=vexRT[Ch3];
		}
		else
		{
			motor[D1]=0;
		}
		if(abs(vexRT[Ch2]) > thresholddrive)
		{
			motor[D2]=vexRT[Ch2];
		}
		else
		{
			motor[D2]=0;
		}
		if((vexRT[Btn5D]==1) && (vexRT[Btn5U]==0))
		{
			motor[CK]=-63;
		}
		if((vexRT[Btn5U]==1) && (vexRT[Btn5D]==0))
		{
			motor[CK]=63;
		}
		else if((vexRT[Btn5U]==0) && (vexRT[Btn5D]==0))
		{
			motor[CK]=0;
		}
		if((vexRT[Btn6D]==1) && (vexRT[Btn6U]==0))
		{
			motor[LL]=-127;
			motor[RL]=-127;
		}
		if((vexRT[Btn6U]==1) && (vexRT[Btn6D]==0))
		{
			motor[LL]=64;
			motor[RL]=64;
		}
		else if((vexRT[Btn6U]==0) && (vexRT[Btn6D]==0))
		{
			motor[LL]=0;
			motor[RL]=0;
		}
		if((vexRT[Btn8D]==1) && (vexRT[Btn8U]==0))
		{
			motor[SK]=-127;
		}
		if((vexRT[Btn8U]==1) && (vexRT[Btn8D]==0))
		{
			motor[SK]=127;
		}
		else if((vexRT[Btn8U]==0) && (vexRT[Btn8D]==0))
		{
			motor[SK]=0;
		}
	}
}
//////////////////////////////////////////////////////////////////////////////////////
task singleControllerTest()//SINGLE ARCADE TEST
{//These values are good
	while(true)
	{
		if((abs(vexRT[Ch3]) > thresholddrive) || (abs(vexRT[Ch4]) > thresholddrive))
		{
			motor[D1] = (vexRT[Ch3] + vexRT[Ch4]);
			motor[D2] = (vexRT[Ch3] - vexRT[Ch4]);
		}
		else
		{
			motor[D1]=0;
			motor[D2]=0;
		}
		if((abs(vexRT[Ch2]) > thresholdlift) && ((SensorValue[PL] >= 250) && (SensorValue[PL] <= 350)))
		{
			motor[LL]=vexRT[Ch2];
			motor[RL]=vexRT[Ch2];
		}
		else if(abs(vexRT[Ch2]) < thresholdlift)
		{
			motor[LL]=0;
			motor[RL]=0;
		}
		else if(((vexRT[Ch2]) > thresholdlift) && (SensorValue[PL] >= 351))
		{
			motor[LL]=0;
			motor[RL]=0;
		}
		else if(((vexRT[Ch2]) < -thresholdlift) && (SensorValue[PL] <= 249))
		{
			motor[LL]=0;
			motor[RL]=0;
		}
		if((vexRT[Btn5D]==1) && (vexRT[Btn5U]==1))
		{
			motor[CK]=-63;
		}
		if((vexRT[Btn5U]==1) && (vexRT[Btn5D]==0))
		{
			motor[CK]=63;
		}
		else if((vexRT[Btn5U]==0) && (vexRT[Btn5D]==0))
		{
			motor[CK]=0;
		}
		if((vexRT[Btn8D]==1) && (vexRT[Btn8U]==0))
		{
			motor[SK]=-127;
		}
		if((vexRT[Btn8U]==1) && (vexRT[Btn8D]==0))
		{
			motor[SK]=127;
		}
		else if((vexRT[Btn8U]==0) && (vexRT[Btn8D]==0))
		{
			motor[SK]=0;
		}
	}
}
//////////////////////////////////////////////////////////////////////////////////////
task singleControllerTest2()//SINGLE TANK TEST
{//These values are good
	while(true)
	{
		if(abs(vexRT[Ch3]) > thresholddrive)
		{
			motor[D1]=vexRT[Ch3];
		}
		else
		{
			motor[D1]=0;
		}
		if(abs(vexRT[Ch2]) > thresholddrive)
		{
			motor[D2]=vexRT[Ch2];
		}
		else
		{
			motor[D2]=0;
		}
		if((vexRT[Btn5D]==1) && (vexRT[Btn5U]==0))
		{
			motor[CK]=-127;
		}
		if((vexRT[Btn5U]==1) && (vexRT[Btn5D]==0))
		{
			motor[CK]=127;
		}
		else if(((vexRT[Btn5U]==0) && (vexRT[Btn5D]==0)) && (SensorValue[PIN] >= 1050))//adjust this value dum dum
		{
			motor[CK]=50;
		}
		else if((vexRT[Btn5U]==0) && (vexRT[Btn5D]==0))
		{
			motor[CK]=0;
		}
		else if(((vexRT[Btn5U]==1) && (SensorValue[PIN] <= 250)) || ((vexRT[Btn5D]==1) && (SensorValue[PIN] >= 1050)))//these values aren't exact, get workin
		{
			motor[CK]=0;
		}
		if(((vexRT[Btn6D]==1) && (vexRT[Btn6U]==0)) && (SensorValue[PL] >= 250))
		{
			motor[LL]=-127;
			motor[RL]=-127;
		}
		if(((vexRT[Btn6U]==1) && (vexRT[Btn6D]==0)) && (SensorValue[PL] <= 350))
		{
			motor[LL]=127;
			motor[RL]=127;
		}
		else if((vexRT[Btn6U]==0) && (vexRT[Btn6D]==0))
		{
			motor[LL]=0;
			motor[RL]=0;
		}
		else if(((vexRT[Btn6U]==1) && (vexRT[Btn6D]==0)) && (SensorValue[PL] >= 351))
		{
			motor[LL]=0;
			motor[RL]=0;
		}
		else if(((vexRT[Btn6D]==1) && (vexRT[Btn6U]==0)) && (SensorValue[PL] <= 249))
		{
			motor[LL]=0;
			motor[RL]=0;
		}
		if((vexRT[Btn8D]==1) && (vexRT[Btn8U]==0))
		{
			motor[SK]=-127;
		}
		if((vexRT[Btn8U]==1) && (vexRT[Btn8D]==0))
		{
			motor[SK]=127;
		}
		else if((vexRT[Btn8U]==0) && (vexRT[Btn8D]==0))
		{
			motor[SK]=0;
		}
	}
}
//////////////////////////////////////////////////////////////////////////////////////
task doubleController1()//DOUBLE BUMPER LIFT
{
	while(true)
	{
		if((abs(vexRT[Ch3]) > thresholddrive) || (abs(vexRT[Ch4]) > thresholddrive))
		{
			motor[D1] = (vexRT[Ch3] + vexRT[Ch4]);
			motor[D2] = (vexRT[Ch3] - vexRT[Ch4]);
		}
		else
		{
			motor[D1]=0;
			motor[D2]=0;
		}
		if((vexRT[Btn6UXmtr2]==1) && (vexRT[Btn6DXmtr2]==0))
		{
			motor[LL]=127;
			motor[RL]=127;
		}
		if((vexRT[Btn6DXmtr2]==1) && (vexRT[Btn6UXmtr2]==0))
		{
			motor[LL]=-127;
			motor[RL]=-127;
		}
		else if((vexRT[Btn6DXmtr2]==0) && (vexRT[Btn6UXmtr2]==0))
		{
			motor[LL]=0;
			motor[RL]=0;
		}
		if((vexRT[Btn5DXmtr2]==1) && (vexRT[Btn6UXmtr2]==0))
		{
			motor[CK]=-64;
		}
		if((vexRT[Btn5UXmtr2]==1) && (vexRT[Btn5DXmtr2]==0))
		{
			motor[CK]=64;
		}
		else if((vexRT[Btn5UXmtr2]==0) && (vexRT[Btn5DXmtr2]==0))
		{
			motor[CK]=0;
		}
		if((vexRT[Btn8UXmtr2]==1) && (vexRT[Btn8DXmtr2]==0))
		{
			motor[SK]=127;
		}
		if((vexRT[Btn8DXmtr2]==1) && (vexRT[Btn8UXmtr2]==0))
		{
			motor[SK]=-127;
		}
		else if((vexRT[Btn8DXmtr2]==0) && (vexRT[Btn8UXmtr2]==0))
		{
			motor[SK]=0;
		}
	}
}
//////////////////////////////////////////////////////////////////////////////////////
task doubleController2()//DOUBLE STICK LIFT
{
	while(true)
	{
		if(abs(vexRT[Ch3Xmtr2]) > thresholdlift)
		{
			motor[LL]=vexRT[Ch3Xmtr2];
			motor[RL]=vexRT[Ch3Xmtr2];
		}
		else
		{
			motor[LL]=0;
			motor[RL]=0;
		}
		if((abs(vexRT[Ch2Xmtr2]) > thresholdCK))
		{
			motor[CK]=vexRT[Ch2Xmtr2];
		}
		else
		{
			motor[CK]=0;
		}
		if((abs(vexRT[Ch3]) > thresholddrive) || (abs(vexRT[Ch4]) > thresholddrive))
		{
			motor[D1] = (vexRT[Ch3] + vexRT[Ch4]);
			motor[D2] = (vexRT[Ch3] - vexRT[Ch4]);
		}
		else
		{
			motor[D1]=0;
			motor[D2]=0;
		}
		if((vexRT[Btn8UXmtr2]==1) && (vexRT[Btn8DXmtr2]==0))
		{
			motor[SK]=127;
		}
		if((vexRT[Btn8DXmtr2]==1) && (vexRT[Btn8UXmtr2]==0))
		{
			motor[SK]=-127;
		}
		else if((vexRT[Btn8DXmtr2]==0) && (vexRT[Btn8UXmtr2]==0))
		{
			motor[SK]=0;
		}
	}
}
//////////////////////////////////////////////////////////////////////////////////////
task doubleControllerTest()//DOUBLE CONTROLLER BUMPER TEST CODE
{//These sensor values should be good, remove this comment when done and tested. PIN especially.
	while(true)
	{
		if((abs(vexRT[Ch3]) > thresholddrive) || (abs(vexRT[Ch4]) > thresholddrive))
		{
			motor[D1] = (vexRT[Ch3] + vexRT[Ch4]);
			motor[D2] = (vexRT[Ch3] - vexRT[Ch4]);
		}
		else
		{
			motor[D1]=0;
			motor[D2]=0;
		}
		if(((vexRT[Btn6UXmtr2]==1) && (vexRT[Btn6DXmtr2]==0)) && (SensorValue[PL] >= 250))//Both of these values should be correct, further testing is needed
		{
			motor[LL]=127;
			motor[RL]=127;
		}
		if(((vexRT[Btn6DXmtr2]==1) && (vexRT[Btn6UXmtr2]==0)) && (SensorValue[PL] <= 350))
		{
			motor[LL]=-127;
			motor[RL]=-127;
		}
		else if((vexRT[Btn6DXmtr2]==0) && (vexRT[Btn6UXmtr2]==0))
		{
			motor[LL]=0;
			motor[RL]=0;
		}
		else if(((vexRT[Btn5UXmtr2]==1) && (vexRT[Btn5DXmtr2]==0)) && (SensorValue[PL] <= 249))
		{
			motor[LL]=0;
			motor[RL]=0;
		}
		else if(((vexRT[Btn5DXmtr2]==1) && (vexRT[Btn5UXmtr2]==0)) && (SensorValue[PL] >= 351))
		{
			motor[LL]=0;
			motor[RL]=0;
		}
		if((vexRT[Btn5DXmtr2]==1) && (vexRT[Btn6UXmtr2]==0))
		{
			motor[CK]=-127;
		}
		if((vexRT[Btn5UXmtr2]==1) && (vexRT[Btn5DXmtr2]==0))
		{
			motor[CK]=127;
		}
		else if(((vexRT[Btn5UXmtr2]==0) && (vexRT[Btn5DXmtr2]==0)) && (SensorValue[PIN] >= 1050))//adjust this value as well when the time comes
		{
			motor[CK]=50;
		}
		else if(((vexRT[Btn5UXmtr2]==0) && (vexRT[Btn5DXmtr2]==0)) || (((vexRT[Btn5UXmtr2]==1) && (SensorValue[PIN] <= 250)) || ((vexRT[Btn5DXmtr2]==1) && (SensorValue[PIN] >= 1050))))//these values aren't exact yet, make it have a min and max where the ranges can go
		{
			motor[CK]=0;
		}
		if((vexRT[Btn8UXmtr2]==1) && (vexRT[Btn8DXmtr2]==0))
		{
			motor[SK]=127;
		}
		if((vexRT[Btn8DXmtr2]==1) && (vexRT[Btn8UXmtr2]==0))
		{
			motor[SK]=-127;
		}
		else if((vexRT[Btn8DXmtr2]==0) && (vexRT[Btn8UXmtr2]==0))
		{
			motor[SK]=0;
		}
	}
}
//////////////////////////////////////////////////////////////////////////////////////
task doubleControllerTest2()//DOUBLE CONTROLLER STICK LIFT TEST
{//These sensor values also need to be adjusted. PIN especially. Remove this when done and tested.
	while(true)
	{
		if((vexRT[Ch3Xmtr2] > thresholdlift) && (SensorValue[PL] >= 250))//might not need to be adjusted
		{
			motor[LL]=vexRT[Ch3Xmtr2];
			motor[RL]=vexRT[Ch3Xmtr2];
		}
		if((vexRT[Ch3Xmtr2] < -thresholdlift) && (SensorValue[PL] <= 1049))//might not need to be adjusted
		{
			motor[LL]=vexRT[Ch3Xmtr2];
			motor[RL]=vexRT[Ch3Xmtr2];
		}
		else if(abs(vexRT[Ch3Xmtr2]) < thresholdlift)
		{
			motor[LL]=0;
			motor[RL]=0;
		}
		else if((vexRT[Ch3Xmtr2] > thresholdlift) && (SensorValue[PL] >= 351))//might not need to be adjusted
		{
			motor[LL]=0;
			motor[RL]=0;
		}
		else if((vexRT[Ch3Xmtr2] < -thresholdlift) && (SensorValue[PL] <= 249))//might not need to be adjusted
		{
			motor[LL]=0;
			motor[RL]=0;
		}
		if((abs(vexRT[Ch2Xmtr2]) < thresholdCK) && (SensorValue[PIN] <= 550))//adjust these values so the claw is partially open when it closes on its own dum dum
		{
			motor[CK]=50;
		}
		if(((vexRT[Ch2Xmtr2]) < -thresholdCK) && (SensorValue[PIN] <= 1049))//adjust
		{
			motor[CK]=vexRT[Ch2Xmtr2];
		}
		else if(((vexRT[Ch2Xmtr2]) > thresholdCK) && (SensorValue[PIN] >= 1050))//adjust
		{
			motor[CK]=0;
		}
		else if((vexRT[Ch2Xmtr2]) > maxthresholdCK)
		{
			motor[CK]=85;
		}
		else if((vexRT[Ch2Xmtr2]) < -maxthresholdCK)
		{
			motor[CK]=-85;
		}
		if((vexRT[Btn8UXmtr2]==1) && (vexRT[Btn8DXmtr2]==0))
		{
			motor[SK]=127;
		}
		if((vexRT[Btn8DXmtr2]==1) && (vexRT[Btn8UXmtr2]==0))
		{
			motor[SK]=-127;
		}
		else if((vexRT[Btn8DXmtr2]==0) && (vexRT[Btn8UXmtr2]==0))
		{
			motor[SK]=0;
		}
	}
}
//////////////////////////////////////////////////////////////////////////////////////
void waitForPress()
{
	while(nLCDButtons==0)
	{
		wait1Msec(5);
	}
}
void waitForRelease()
{
	while(nLCDButtons!=0)
	{
		wait1Msec(5);
	}
}
//////////////////////////////////////////////////////////////////////////////////////
void pre_auton()
{
	clearLCDLine(0);
	clearLCDLine(1);
	//DRIVER SELECT
	while(nLCDButtons!=centerButton)
	{
		bLCDBacklight=true;
		switch(driver)
		{
		case 0:
			displayLCDCenteredString(0, "Single Arcade");
			displayLCDCenteredString(1, "<		 Enter		>");
			waitForPress();
			if(nLCDButtons == leftButton)
			{
				waitForRelease();
				driver=7;
			}
			else if(nLCDButtons == rightButton)
			{
				waitForRelease();
				driver++;
			}
			break;
		case 1:
			displayLCDCenteredString(0, "Single Tank");
			displayLCDCenteredString(1, "<		 Enter		>");
			waitForPress();
			if(nLCDButtons == leftButton)
			{
				waitForRelease();
				driver--;
			}
			else if(nLCDButtons == rightButton)
			{
				waitForRelease();
				driver++;
			}
			break;
		case 2:
			displayLCDCenteredString(0, "Double B Lift");
			displayLCDCenteredString(1, "<		 Enter		>");
			waitForPress();
			if(nLCDButtons == leftButton)
			{
				waitForRelease();
				driver--;
			}
			else if(nLCDButtons == rightButton)
			{
				waitForRelease();
				driver++;
			}
			break;
		case 3:
			displayLCDCenteredString(0, "Double S Lift");
			displayLCDCenteredString(1, "<		 Enter		>");
			waitForPress();
			if(nLCDButtons == leftButton)
			{
				waitForRelease();
				driver--;
			}
			else if(nLCDButtons == rightButton)
			{
				waitForRelease();
				driver++;
			}
			break;
		case 4:
			displayLCDCenteredString(0, "Test Code SA");
			displayLCDCenteredString(1, "<		 Enter		>");
			waitForPress();
			if(nLCDButtons == leftButton)
			{
				waitForRelease();
				driver--;
			}
			else if(nLCDButtons == rightButton)
			{
				waitForRelease();
				driver++;
			}
			break;
		case 5:
			displayLCDCenteredString(0, "Test Code SB");
			displayLCDCenteredString(1, "<		 Enter		>");
			waitForPress();
			if(nLCDButtons == leftButton)
			{
				waitForRelease();
				driver--;
			}
			else if(nLCDButtons == rightButton)
			{
				waitForRelease();
				driver++;
			}
			break;
		case 6:
			displayLCDCenteredString(0, "Test Code DB");
			displayLCDCenteredString(1, "<		 Enter		>");
			waitForPress();
			if(nLCDButtons == leftButton)
			{
				waitForRelease();
				driver--;
			}
			else if(nLCDButtons == rightButton)
			{
				waitForRelease();
				driver++;
			}
			break;
		case 7:
			displayLCDCenteredString(0, "Test Code DS");
			displayLCDCenteredString(1, "<		 Enter		>");
			waitForPress();
			if(nLCDButtons == leftButton)
			{
				waitForRelease();
				driver--;
			}
			else if(nLCDButtons == rightButton)
			{
				waitForRelease();
				driver=0;
			}
			break;
		default:
			driver = 0;
			break;
		}
	}
	//////////////////////////////////////////////////////////////////////////////////////
	clearLCDLine(0);
	clearLCDLine(1);
	displayLCDCenteredString(0, "Initializing...");
	displayLCDCenteredString(1, "One moment...");
	wait(1);
	//////////////////////////////////////////////////////////////////////////////////////
	//AUTON/SKILLS SELECT
	while(nLCDButtons!=centerButton)
	{
		switch(count)
		{
		case 0:
			displayLCDCenteredString(0, "Autonomous 1");
			displayLCDCenteredString(1, "<		 Enter		>");
			waitForPress();
			if(nLCDButtons == leftButton)
			{
				waitForRelease();
				count=2;
			}
			else if(nLCDButtons == rightButton)
			{
				waitForRelease();
				count++;
			}
			break;
		case 1:
			displayLCDCenteredString(0, "Gyro Test");
			displayLCDCenteredString(1, "<		Enter		>");
			waitForPress();
			if(nLCDButtons == leftButton)
			{
				waitForRelease();
				count--;
			}
			else if(nLCDButtons == rightButton)
			{
				waitForRelease();
				count++;
			}
			break;
		case 2:
			displayLCDCenteredString(0, "P Skillz Yo");
			displayLCDCenteredString(1, "<		 Enter		>");
			waitForPress();
			if(nLCDButtons == leftButton)
			{
				waitForRelease();
				count--;
			}
			else if(nLCDButtons == rightButton)
			{
				waitForRelease();
				count=0;
			}
			break;
		default:
			count=0;
			break;
		}
	}
}
//////////////////////////////////////////////////////////////////////////////////////
task autonomous()
{
	clearLCDLine(0);
	clearLCDLine(1);
	switch(count)
	{
	case 0:
		displayLCDCenteredString(0, "Autonomous 1");
		displayLCDCenteredString(1, "is running");
		wait1Msec(250);
		{
			motor[D1]=127;
			motor[D2]=127;
			wait1Msec(500);
			motor[D1]=0;
			motor[D2]=0;
			motor[LL]=127;
			motor[RL]=127;
			wait1Msec(750);
			motor[LL]=0;
			motor[RL]=0;
		}
		break;
	case 1:
		SensorValue[Gyro]=0;
		wait1Msec(1225);//This is for the gyro sensor to calibrate
		displayLCDCenteredString(0, "Gyro Test");
		displayLCDCenteredString(1, "Is running");
		{
			motor[D1]=127;
			motor[D2]=127;
			wait1Msec(500);
			motor[D1]=0;
			motor[D2]=0;
			while(true)
			{
				while((SensorValue[Gyro]) <= 2650)
				{
					motor[D1]=127;
					motor[D2]=-127;
				}
				while((SensorValue[Gyro]) >= 2651)
				{
					wait1Msec(500);
					motor[LL]=127;
					motor[RL]=127;
					if((SensorValue[PL]) >= 350)
					{
						motor[LL]=0;
						motor[RL]=0;
					}
				}
			}
		}
		break;
	case 2:
		displayLCDCenteredString(0, "Skillz");
		displayLCDCenteredString(1, "are runnin dawg");
		wait1Msec(250);
		{
			//////////////////////////////////////////////////////////////////////////////////////
		}
		break;
	default:
		displayLCDCenteredString(0, "No valid choice");
		displayLCDCenteredString(1, "was made dawg :/");
		break;
	}
}
//////////////////////////////////////////////////////////////////////////////////////
task usercontrol()
{
	clearLCDLine(0);
	clearLCDLine(1);
	switch(driver)
	{
	case 0:
		displayLCDCenteredString(0, "Single Arcade");
		displayLCDCenteredString(1, "Is Running");
		{
			startTask(singleController1);
			wait(3);
			{
				startTask(LCD);
			}
		}
		break;
	case 1:
		displayLCDCenteredString(0, "Single Tank");
		displayLCDCenteredString(1, "Is Running");
		{
			startTask(singleController2);
			wait(3);
			{
				startTask(LCD);
			}
		}
		break;
	case 2:
		displayLCDCenteredString(0, "Double B Lift");
		displayLCDCenteredString(1, "Is Running");
		{
			startTask(doubleController1);
			wait(3);
			{
				startTask(LCD);
			}
		}
		break;
	case 3:
		displayLCDCenteredString(0, "Double S Lift");
		displayLCDCenteredString(1, "Is Running");
		{
			startTask(doubleController2);
			wait(3);
			{
				startTask(LCD);
			}
		}
		break;
	case 4:
		displayLCDCenteredString(0, "Single A Test");
		displayLCDCenteredString(1, "Is Running");
		{
			startTask(singleControllerTest);
			wait(3);
			{
				startTask(LCD);
			}
		}
		break;
	case 5:
		displayLCDCenteredString(0, "Single T Test");
		displayLCDCenteredString(1, "Is Running");
		{
			startTask(singleControllerTest2);
			wait(3);
			{
				startTask(LCD);
			}
		}
		break;
	case 6:
		displayLCDCenteredString(0, "Double B Test");
		displayLCDCenteredString(1, "Is Running");
		{
			startTask(doubleControllerTest);
			wait(3);
			{
				startTask(LCD);
			}
		}
		break;
	case 7:
		displayLCDCenteredString(0, "Double S Test");
		displayLCDCenteredString(1, "Is Running");
		{
			startTask(doubleControllerTest2);
			wait(3);
			{
				startTask(LCD);
			}
		}
		break;
	default:
		displayLCDCenteredString(0, "I Guess it's");
		displayLCDCenteredString(1, "Single A then!");
		{
			startTask(singleController1);
			wait(3);
			{
				startTask(LCD);
			}
		}
		break;
	}
}
//Weekly journal thing. Updated weekly/daily depending on how I feel on thoughts and such.//
//#gayson2k17
//imma die from programming this year help.
//i want to end my life right now.
//lcd functions are a pain in the arse.
//a few days later and i still want to die.
//this still makes no sense please help.
//im about to give up and just go to the vex forums.
//admin still wont let me into the forums kms.
//a few days later the forum responded and i think i got it but everyone else is hogging the batteries wtf.
//everything works now i can die in peace.
//everything has gone wrong in the tournament code i have given up.
//waste of 100+ lines of code.
//i was proven wrong it was 80 lines on the dot.
//this should all compile nicely.
//OHECKIWASWRONG.jpg
//i have decided to give up on the tournament code due to pre-existing stress and other things oops sorry not sorry @ my team.
//i was gonna use a gyro sensor and then i looked at the code.
//gyro code examples are very scary.
//lets get shtuff goin.
//i got shtuff goin.
//lets get shtuff tested.
//shtuff was tested and this thing is a little bit on the yikes side.
//dang, 750 lines already.
//what happened to our bot it doesn't work anymore ono.
//we went 3/5 woo.
//new code new me.
//oh heck where did 900 lines of code come from??????????
//?????like??????????aren't I???? ???just the greatest?????? ?????programmer??? for?? the team???????
//that was obviously sarcastic I hate myself oml that was painful to write.
//I wish I had that much self confidence
//feelsbadman.jpg
//I feel sorry if someone ends up reading this later on.
//I think I have the hang of things now.
//It's thanksgiving and me being the little child I am I'm programming while everyone's gathered.
//Ooops.
//Things are going smoothly on the programming end.
//Things are not going smoothly on the building end.
//Abbreviations are done and I think I have the sensor value stuff under control and tamed this time.
//Almost 1,000 lines already, wow.
//'Tis been a journey of the ages.
//I'm still not doing PID this year to save sanity for myself.
//feelsgoodman.jpg
//I actually might be doing PID this year bc it's not to terrible
//feelsgoodagainman.jpg
//Now there's 1000 lines of actual code. Not comments.
//NVM PID is pretty scary but I'll still probably do it when I have the opportunity.
//Gyro code isn' hard at all I'm just a whimp oops.
//After some compression, we now have just short of 950 lines.
